import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import albumentations as A
from albumentations.pytorch import ToTensorV2
import numpy as np
from PIL import Image
import json
import matplotlib.pyplot as plt
from sklearn.utils.class_weight import compute_class_weight
from pycocotools import mask as maskUtils
import os

# 1. Конфигурация
CLASSES = ['background', 'city', 'field', 'forest', 'water']  # Фон должен быть первым
CLASS_COLORS = {
    0: [0, 0, 0],        # background - черный
    1: [255, 0, 0],      # city - красный
    2: [255, 255, 0],    # field - желтый
    3: [0, 255, 0],      # forest - зеленый
    4: [0, 0, 255]       # water - синий
}
NUM_CLASSES = len(CLASSES)
DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'

# 2. Исправленный класс Dataset
class SatelliteDataset(Dataset):
    def __init__(self, image_path, annotation_path, transform=None):
        self.image = np.array(Image.open(image_path).convert('RGB'))
        with open(annotation_path) as f:
            self.coco_data = json.load(f)
        self.transform = transform
        self.masks = self._load_masks()
        
    def _load_masks(self):
        h, w = self.image.shape[:2]
        mask = np.zeros((h, w), dtype=np.uint8)
        
        for ann in self.coco_data['annotations']:
            if isinstance(ann['segmentation'], list):
                # Полигональная аннотация
                if len(ann['segmentation']) > 0:
                    rle = maskUtils.frPyObjects(ann['segmentation'], h, w)
                    m = maskUtils.decode(rle)
                    if m.ndim == 3:
                        m = m.sum(axis=2) > 0
            elif isinstance(ann['segmentation'], dict):
                # RLE аннотация
                m = maskUtils.decode(ann['segmentation'])
            else:
                continue
                
            mask[m > 0] = ann['category_id']
            
        return mask
    
    def __len__(self):
        return 100  # Генерируем 100 аугментированных вариантов
    
    def __getitem__(self, idx):
        if self.transform:
            transformed = self.transform(image=self.image, mask=self.masks)
            return transformed['image'], transformed['mask']
        return self.image, self.masks

# 3. Аугментации
def get_transform():
    return A.Compose([
        A.RandomCrop(512, 512),
        A.HorizontalFlip(p=0.5),
        A.VerticalFlip(p=0.5),
        A.RandomRotate90(p=0.5),
        A.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ToTensorV2()
    ])

# 4. Функция для вычисления весов классов
def get_class_weights(mask):
    classes = np.unique(mask)
    weights = compute_class_weight('balanced', classes=classes, y=mask.flatten())
    weight_dict = {cls: weight for cls, weight in zip(classes, weights)}
    return torch.tensor([weight_dict.get(i, 1.0) for i in range(NUM_CLASSES)]).float().to(DEVICE)

# 5. Обучение с исправлениями
def train():
    dataset = SatelliteDataset(IMAGE_PATH, ANNOTATION_PATH, get_transform())
    loader = DataLoader(dataset, batch_size=4, shuffle=True)
    
    model = SegModel().to(DEVICE)
    optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)
    
    # Веса классов с обработкой отсутствующих классов
    weights = get_class_weights(dataset.masks)
    criterion = nn.CrossEntropyLoss(weight=weights)
    
    train_loss = []
    train_iou = []
    
    for epoch in range(20):
        model.train()
        epoch_loss = 0
        epoch_iou = 0
        
        for images, masks in loader:
            images, masks = images.to(DEVICE), masks.to(DEVICE)
            
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, masks.long())
            loss.backward()
            optimizer.step()
            
            epoch_loss += loss.item()
            epoch_iou += calculate_iou(outputs, masks)
        
        epoch_loss /= len(loader)
        epoch_iou /= len(loader)
        train_loss.append(epoch_loss)
        train_iou.append(epoch_iou)
        
        print(f'Epoch {epoch+1}, Loss: {epoch_loss:.4f}, IoU: {epoch_iou:.4f}')
    
    # Визуализация
    plt.figure(figsize=(12, 5))
    plt.subplot(1, 2, 1)
    plt.plot(train_loss, label='Loss')
    plt.title('Training Loss')
    plt.xlabel('Epoch')
    plt.legend()
    
    plt.subplot(1, 2, 2)
    plt.plot(train_iou, label='IoU', color='orange')
    plt.title('Training IoU')
    plt.xlabel('Epoch')
    plt.legend()
    
    plt.tight_layout()
    plt.show()
    
    return model

def calculate_iou(preds, targets):
    smooth = 1e-6
    preds = torch.argmax(preds, dim=1)
    intersection = (preds == targets).float().sum()
    union = (preds | targets).float().sum()
    return (intersection + smooth) / (union + smooth)

# Запуск
model = train()
