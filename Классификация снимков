import os
import zipfile
import io
import numpy as np
from PIL import Image
from tqdm import tqdm
import torch
import torch.nn as nn
from torchvision import models, transforms
from sklearn.cluster import KMeans
from google.colab import drive
def show_first_10_images(zip_path):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–≤—ã–µ 10 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ ZIP-–∞—Ä—Ö–∏–≤–∞ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç JPG, PNG, TIFF)
    :param zip_path: –ø—É—Ç—å –∫ ZIP-–∞—Ä—Ö–∏–≤—É —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
        if not os.path.exists(zip_path):
            print(f"–û—à–∏–±–∫–∞: —Ñ–∞–π–ª {zip_path} –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return

        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –∞—Ä—Ö–∏–≤–µ (–¥–æ–±–∞–≤–ª–µ–Ω TIFF)
            image_files = [f for f in zip_ref.namelist()
                         if f.lower().endswith(('.jpg', '.jpeg', '.png', '.tif', '.tiff'))]

            if not image_files:
                print("–í –∞—Ä—Ö–∏–≤–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π!")
                return

            print(f"–ù–∞–π–¥–µ–Ω–æ {len(image_files)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π. –ü–æ–∫–∞–∑—ã–≤–∞—é –ø–µ—Ä–≤—ã–µ 10:")

            # –°–æ–∑–¥–∞–µ–º —Ñ–∏–≥—É—Ä—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            plt.figure(figsize=(20, 12))  # –£–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

            for i, img_name in enumerate(image_files[:10]):
                try:
                    with zip_ref.open(img_name) as img_file:
                        img = Image.open(io.BytesIO(img_file.read()))

                        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º TIFF –≤ RGB –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                        if img_name.lower().endswith(('.tif', '.tiff')):
                            if img.mode == 'I;16':
                                img = img.point(lambda p: p * (1. / 256)).convert('L')
                            elif img.mode not in ('RGB', 'L'):
                                img = img.convert('RGB')

                        # –í—ã–≤–æ–¥–∏–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                        plt.subplot(2, 5, i+1)
                        plt.imshow(img, cmap='gray' if img.mode == 'L' else None)
                        plt.title(os.path.basename(img_name))
                        plt.axis('off')

                except Exception as img_error:
                    print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ {img_name}: {str(img_error)}")

            plt.tight_layout()
            plt.show()

    except Exception as main_error:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –∞—Ä—Ö–∏–≤–æ–º: {str(main_error)}")

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
archive_path = '/content/drive/MyDrive/–¶–∏—Ñ—Ä–æ–≤–∞—è –∫–∞—Ñ–µ–¥—Ä–∞/–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è/OutputFotos100.zip'
show_first_10_images(archive_path)
# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ Google Drive
drive.mount('/content/drive')

# –ü—É—Ç—å –∫ –∞—Ä—Ö–∏–≤—É (–∑–∞–ø—Ä–æ—Å–∏–º —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
archive_path = '/content/drive/MyDrive/–¶–∏—Ñ—Ä–æ–≤–∞—è –∫–∞—Ñ–µ–¥—Ä–∞/–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è/OutputFotos100.zip'

# –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤ (–∫–ª–∞—Å—Ç–µ—Ä–æ–≤)
num_classes = int(input("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤ –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏: ").strip())

# –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É Classification
output_dir = os.path.join(os.path.dirname(archive_path), 'Classification')
os.makedirs(output_dir, exist_ok=True)

# –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∞–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞
for i in range(num_classes):
    os.makedirs(os.path.join(output_dir, f'class_{i}'), exist_ok=True)
# –ú–æ–¥–µ–ª—å –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
class FeatureExtractor(nn.Module):
    def __init__(self):
        super().__init__()
        self.model = models.resnet18(pretrained=True)
        self.model = nn.Sequential(*list(self.model.children())[:-1])  # –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–æ–π

    def forward(self, x):
        return self.model(x).squeeze()

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ TIFF
def load_tiff_image(img_data):
    img = Image.open(io.BytesIO(img_data))
    if img.mode == 'I;16':
        img = img.point(lambda p: p * (1./256)).convert('L')
    elif img.mode not in ('RGB', 'L'):
        img = img.convert('RGB')
    return img

# –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

# –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ –∏–∑ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π TIFF)
def extract_features(zip_path):
    model = FeatureExtractor().eval().to('cuda' if torch.cuda.is_available() else 'cpu')
    features = []
    filenames = []

    with zipfile.ZipFile(zip_path, 'r') as zf:
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É TIFF
        image_files = [f for f in zf.namelist() if f.lower().endswith(('jpg', 'jpeg', 'png', 'tif', 'tiff'))]

        for file in tqdm(image_files, desc="–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤"):
            try:
                with zf.open(file) as img_file:
                    img_data = img_file.read()

                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ TIFF
                    if file.lower().endswith(('tif', 'tiff')):
                        img = load_tiff_image(img_data)
                    else:
                        img = Image.open(io.BytesIO(img_data)).convert('RGB')

                    img_tensor = transform(img).unsqueeze(0).to('cuda' if torch.cuda.is_available() else 'cpu')

                    with torch.no_grad():
                        feature = model(img_tensor).cpu().numpy().flatten()

                    features.append(feature)
                    filenames.append(file)
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {file}: {e}")

    return np.array(features), filenames

# –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è —Å –ø–æ–º–æ—â—å—é K-Means
def cluster_images(features, filenames, n_clusters):
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    clusters = kmeans.fit_predict(features)
    return clusters

# –ö–æ–ø–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞–ø–∫–∏
def copy_to_classes(zip_path, filenames, clusters, output_dir):
    with zipfile.ZipFile(zip_path, 'r') as zf:
        for filename, cluster in tqdm(zip(filenames, clusters), desc="–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"):
            try:
                with zf.open(filename) as img_file:
                    img_data = img_file.read()

                    output_path = os.path.join(output_dir, f'class_{cluster}', os.path.basename(filename))

                    with open(output_path, 'wb') as f:
                        f.write(img_data)
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏ {filename}: {e}")
# –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å
print("\n–ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏...")
features, filenames = extract_features(archive_path)
print("\n–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π...")
clusters = cluster_images(features, filenames, num_classes)
print("\n–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤...")
copy_to_classes(archive_path, filenames, clusters, output_dir)

print(f"\n–ì–æ—Ç–æ–≤–æ! –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–æ {num_classes} –∫–ª–∞—Å—Å–∞–º –≤ –ø–∞–ø–∫–µ: {output_dir}")
def count_images_per_class(output_dir):
    """
    –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –∫–∞–∂–¥–æ–π –∫–ª–∞—Å—Å–æ–≤–æ–π –ø–∞–ø–∫–µ
    :param output_dir: –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
    :return: —Å–ª–æ–≤–∞—Ä—å —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –∫–ª–∞—Å—Å–∞–º
    """
    class_counts = {}

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
    if not os.path.exists(output_dir):
        print(f"–û—à–∏–±–∫–∞: –ø–∞–ø–∫–∞ {output_dir} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!")
        return None

    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–ª–∞—Å—Å–æ–≤ (–ø–æ–¥–ø–∞–ø–æ–∫)
    classes = [d for d in os.listdir(output_dir)
              if os.path.isdir(os.path.join(output_dir, d)) and d.startswith('class_')]

    if not classes:
        print("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –∫–ª–∞—Å—Å–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!")
        return None

    print("\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –∫–ª–∞—Å—Å–∞–º:")
    print("-" * 30)

    for class_dir in sorted(classes):
        class_path = os.path.join(output_dir, class_dir)
        # –°—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        images = [f for f in os.listdir(class_path)
                 if f.lower().endswith(('.jpg', '.jpeg', '.png', '.tif', '.tiff'))]
        count = len(images)
        class_counts[class_dir] = count
        print(f"{class_dir}: {count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")

    print("-" * 30)
    total = sum(class_counts.values())
    print(f"–í—Å–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {total}")

    return class_counts

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–æ—Å–ª–µ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
class_stats = count_images_per_class(output_dir)
import os
from google.colab import drive

def print_directory_tree(start_path, indent=''):
    """
    –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã–≤–æ–¥–∏—Ç –¥–µ—Ä–µ–≤–æ –∫–∞—Ç–∞–ª–æ–≥–æ–≤ –∏ —Ñ–∞–π–ª–æ–≤, –Ω–∞—á–∏–Ω–∞—è —Å start_path.

    Args:
        start_path (str): –ü—É—Ç—å –∫ –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–µ
        indent (str): –û—Ç—Å—Ç—É–ø –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ)
    """
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å
    if not os.path.exists(start_path):
        print(f"–ü—É—Ç—å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {start_path}")
        return

    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–∞–ø–∫–µ
    try:
        items = os.listdir(start_path)
    except PermissionError:
        print(f"{indent}[–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–µ] {os.path.basename(start_path)}/")
        return

    # –†–∞–∑–¥–µ–ª—è–µ–º —Ñ–∞–π–ª—ã –∏ –ø–∞–ø–∫–∏
    files = []
    dirs = []
    for item in items:
        item_path = os.path.join(start_path, item)
        if os.path.isfile(item_path):
            files.append(item)
        else:
            dirs.append(item)

    # –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–π –ø–∞–ø–∫–µ
    print(f"{indent}üìÅ {os.path.basename(start_path)}/")

    # –í—ã–≤–æ–¥–∏–º —Ñ–∞–π–ª—ã
    if files:
        print(f"{indent}‚îÇ   üóÑÔ∏è –§–∞–π–ª–æ–≤: {len(files)}")
        # –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –≤—ã–≤–æ–¥–∏—Ç—å –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ:
        # for file in files:
        #     print(f"{indent}‚îÇ   ‚îú‚îÄ {file}")

    # –í—ã–≤–æ–¥–∏–º –ø–æ–¥–ø–∞–ø–∫–∏ –∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏—Ö –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
    for directory in dirs:
        dir_path = os.path.join(start_path, directory)
        print_directory_tree(dir_path, indent + "‚îÇ   ")

# –ú–æ–Ω—Ç–∏—Ä—É–µ–º Google Drive (–µ—Å–ª–∏ –µ—â—ë –Ω–µ —Å–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω)
if not os.path.exists('/content/drive'):
    drive.mount('/content/drive')

# –ü—É—Ç—å –∫ –≤–∞—à–µ–π –ø–∞–ø–∫–µ
target_path = '/content/drive/MyDrive/–¶–∏—Ñ—Ä–æ–≤–∞—è –∫–∞—Ñ–µ–¥—Ä–∞/–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è/Classification'

# –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑
print("üå≥ –î–µ—Ä–µ–≤–æ –∫–∞—Ç–∞–ª–æ–≥–æ–≤:")
print_directory_tree(target_path)
