import os
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import segmentation_models_pytorch as smp
from torchvision import transforms
import albumentations as A
from PIL import Image
import tifffile
from google.colab import drive
from sklearn.model_selection import train_test_split  # Добавленный импорт
import cv2  # Также добавлен импорт cv2, который используется в коде

# 1. Монтируем Google Drive и определяем константы
drive.mount('/content/drive')

DATA_ROOT = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/Полный архив'
CLASSES = {
    'Лес': [0, 255, 0],    # Зеленый
    'Поле': [255, 255, 0], # Желтый
    'Город': [255, 0, 0],  # Красный
    'Вода': [0, 0, 255]    # Синий
}

# 2. Определяем преобразования
val_transform = A.Compose([
    A.Resize(100, 100)  # Убрал always_apply=True, так как это недопустимый аргумент для Resize
])

# 3. Класс Dataset (должен быть определен перед использованием)
class SatelliteDataset(Dataset):
    def __init__(self, root_dir, classes, transform=None, mode='train'):
        self.samples = []
        self.transform = transform
        
        for class_name, color in classes.items():
            class_dir = os.path.join(root_dir, class_name)
            if not os.path.exists(class_dir):
                continue
                
            files = [f for f in os.listdir(class_dir) if f.lower().endswith(('.tif', '.tiff', '.png', '.jpg', '.jpeg'))]
            train_files, val_files = train_test_split(files, test_size=0.2, random_state=42)
            
            for f in (train_files if mode == 'train' else val_files):
                self.samples.append((os.path.join(class_dir, f), color))
        
        if not self.samples:
            raise ValueError(f"Не найдено изображений для {mode}")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        img_path, color = self.samples[idx]
        
        try:
            # Чтение изображения
            if img_path.lower().endswith(('.tif', '.tiff')):
                img = tifffile.imread(img_path)
            else:
                img = np.array(Image.open(img_path))
                
            # Нормализация
            if img.dtype == np.uint16:
                img = (img / 256).astype(np.uint8)
            if len(img.shape) == 2:
                img = np.stack([img]*3, axis=-1)
            img = img[:,:,:3]
            
            # Приведение к размеру
            if img.shape[0] != 100 or img.shape[1] != 100:
                img = cv2.resize(img, (100, 100))
            
            # Создание маски
            mask = np.zeros_like(img)
            mask[:] = color
            
            if self.transform:
                augmented = self.transform(image=img, mask=mask)
                img, mask = augmented['image'], augmented['mask']
            
            return transforms.ToTensor()(img), transforms.ToTensor()(mask)
            
        except Exception as e:
            print(f"Ошибка обработки {img_path}: {str(e)}")
            return torch.zeros(3, 100, 100), torch.zeros(3, 100, 100)

# 4. Функция для загрузки модели
def load_saved_model():
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = smp.Unet(
        'resnet34',
        encoder_weights=None,
        classes=3,
        activation='sigmoid'
    ).to(device)
    
    model_path = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/best_model.pth'
    model.load_state_dict(torch.load(model_path))
    model.eval()
    return model, device

# 5. Функция визуализации предсказаний
def visualize_model_predictions(model, device, num_samples=5):
    val_dataset = SatelliteDataset(DATA_ROOT, CLASSES, val_transform, 'val')
    model.eval()
    
    plt.figure(figsize=(15, 5 * num_samples))
    
    for i in range(num_samples):
        try:
            idx = np.random.randint(len(val_dataset))
            image, true_mask = val_dataset[idx]
            image = image.unsqueeze(0).to(device)
            
            with torch.no_grad():
                pred_mask = model(image).sigmoid().squeeze().cpu()
            
            image_np = image.squeeze().cpu().permute(1, 2, 0).numpy()
            true_mask_np = true_mask.permute(1, 2, 0).numpy()
            pred_mask_np = (pred_mask > 0.5).float().permute(1, 2, 0).numpy()
            
            plt.subplot(num_samples, 3, i*3 + 1)
            plt.imshow(image_np)
            plt.title(f"Пример {i+1}")
            plt.axis('off')
            
            plt.subplot(num_samples, 3, i*3 + 2)
            plt.imshow(true_mask_np)
            plt.title("Истинная маска")
            plt.axis('off')
            
            plt.subplot(num_samples, 3, i*3 + 3)
            plt.imshow(pred_mask_np)
            plt.title("Предсказание")
            plt.axis('off')
            
        except Exception as e:
            print(f"Ошибка визуализации: {str(e)}")
    
    plt.tight_layout()
    plt.show()

# 6. Основная функция
def work_with_saved_model():
    model, device = load_saved_model()
    print("Модель успешно загружена!")
    
    print("\nВизуализация предсказаний модели:")
    visualize_model_predictions(model, device)

# Запуск
if __name__ == "__main__":
    work_with_saved_model()
