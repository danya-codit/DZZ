import os
import matplotlib.pyplot as plt
import numpy as np
import torch
import segmentation_models_pytorch as smp

# 1. Загрузка сохраненной модели
def load_saved_model():
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = smp.Unet(
        'resnet34',
        encoder_weights=None,  # Не загружаем imagenet веса, так как у нас свои
        classes=3,
        activation='sigmoid'
    ).to(device)
    
    model_path = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/best_model.pth'
    model.load_state_dict(torch.load(model_path))
    model.eval()
    
    print(f"Модель успешно загружена с {model_path}")
    return model, device

# 2. Визуализация метрик (на примере ваших данных)
def plot_training_metrics():
    # Ваши данные из логов обучения (примерные значения)
    train_loss = [0.731, 0.533, 0.529]  # Добавьте свои реальные значения
    val_loss = [0.902, 0.9, 0.9]        # из процесса обучения
    train_iou = [0.333, 0.667, 0.5]
    val_iou = [0.333, 0.333, 0.333]
    
    plt.figure(figsize=(12, 5))
    
    # График потерь
    plt.subplot(1, 2, 1)
    plt.plot(train_loss, label='Train Loss')
    plt.plot(val_loss, label='Validation Loss')
    plt.title('Training and Validation Loss')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()
    
    # График IoU
    plt.subplot(1, 2, 2)
    plt.plot(train_iou, label='Train IoU')
    plt.plot(val_iou, label='Validation IoU')
    plt.title('Training and Validation IoU')
    plt.xlabel('Epoch')
    plt.ylabel('IoU Score')
    plt.legend()
    
    plt.tight_layout()
    
    # Сохраняем графики
    plots_dir = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/training_plots'
    os.makedirs(plots_dir, exist_ok=True)
    plt.savefig(os.path.join(plots_dir, 'loaded_model_metrics.png'))
    plt.show()
    plt.close()

# 3. Улучшенная функция визуализации предсказаний
def visualize_model_predictions(model, device, num_samples=5):
    # Создаем датасет для валидации
    val_dataset = SatelliteDataset(DATA_ROOT, CLASSES, val_transform, 'val')
    
    model.eval()
    indices = np.random.choice(len(val_dataset), num_samples)
    
    plt.figure(figsize=(15, 5 * num_samples))
    
    for i, idx in enumerate(indices):
        # Получаем данные
        image, true_mask = val_dataset[idx]
        image = image.unsqueeze(0).to(device)
        
        # Делаем предсказание
        with torch.no_grad():
            pred_mask = model(image).sigmoid().squeeze().cpu()
        
        # Преобразуем в numpy
        image_np = image.squeeze().cpu().permute(1, 2, 0).numpy()
        true_mask_np = true_mask.permute(1, 2, 0).numpy()
        pred_mask_np = (pred_mask > 0.5).float().permute(1, 2, 0).numpy()
        
        # Оригинальное изображение
        plt.subplot(num_samples, 3, i*3 + 1)
        plt.imshow(image_np)
        plt.title(f"Пример {i+1}\nОригинал")
        plt.axis('off')
        
        # Истинная маска
        plt.subplot(num_samples, 3, i*3 + 2)
        plt.imshow(true_mask_np)
        plt.title("Истинная маска")
        plt.axis('off')
        
        # Предсказанная маска
        plt.subplot(num_samples, 3, i*3 + 3)
        plt.imshow(pred_mask_np)
        plt.title("Предсказание")
        plt.axis('off')
    
    plt.tight_layout()
    
    # Сохраняем визуализацию
    preds_dir = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/predictions'
    os.makedirs(preds_dir, exist_ok=True)
    plt.savefig(os.path.join(preds_dir, 'loaded_model_predictions.png'))
    plt.show()
    plt.close()

# 4. Основной процесс работы с сохраненной моделью
def work_with_saved_model():
    # Загружаем модель
    model, device = load_saved_model()
    
    # Строим графики (замените значения на свои реальные)
    plot_training_metrics()
    
    # Визуализируем предсказания
    print("\nВизуализация предсказаний модели:")
    visualize_model_predictions(model, device)
    
    # Дополнительно: оценка на валидационном наборе
    evaluate_on_validation(model, device)

# 5. Функция оценки на валидационном наборе
def evaluate_on_validation(model, device):
    from tqdm import tqdm
    
    val_dataset = SatelliteDataset(DATA_ROOT, CLASSES, val_transform, 'val')
    val_loader = DataLoader(val_dataset, batch_size=8)
    
    model.eval()
    total_loss = 0
    total_iou = 0
    criterion = nn.BCEWithLogitsLoss()
    
    with torch.no_grad():
        for images, masks in tqdm(val_loader, desc="Оценка на валидации"):
            images, masks = images.to(device), masks.to(device)
            outputs = model(images)
            
            loss = criterion(outputs, masks)
            preds = (torch.sigmoid(outputs) > 0.5).float()
            iou = (preds * masks).sum() / ((preds + masks).sum() - (preds * masks).sum() + 1e-6)
            
            total_loss += loss.item()
            total_iou += iou.item()
    
    avg_loss = total_loss / len(val_loader)
    avg_iou = total_iou / len(val_loader)
    
    print(f"\nРезультаты на валидационном наборе:")
    print(f"Средний Loss: {avg_loss:.4f}")
    print(f"Средний IoU: {avg_iou:.4f}")

# Запускаем весь процесс
if __name__ == "__main__":
    work_with_saved_model()
