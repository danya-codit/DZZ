import os
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import segmentation_models_pytorch as smp
from torchvision import transforms
import albumentations as A
from PIL import Image
import tifffile
from google.colab import drive
from sklearn.model_selection import train_test_split
import cv2

# Устанавливаем необходимые пакеты
#!pip install imagecodecs
import imagecodecs

# 1. Монтируем Google Drive
drive.mount('/content/drive', force_remount=True)

# 2. Конфигурация путей и классов
DATA_ROOT = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/Полный архив'
CLASSES = {
    'Лес': [0, 255, 0],    # Зеленый
    'Поле': [255, 255, 0], # Желтый
    'Город': [255, 0, 0],  # Красный
    'Вода': [0, 0, 255]    # Синий
}

# 3. Определяем преобразования
val_transform = A.Compose([
    A.Resize(100, 100)
])

# 4. Улучшенная функция для чтения изображений
def read_image(path):
    try:
        # Пробуем прочитать как TIFF
        if path.lower().endswith(('.tif', '.tiff')):
            try:
                return tifffile.imread(path)
            except Exception as e:
                # Если не получилось через tifffile, пробуем через imagecodecs
                try:
                    img = Image.open(path)
                    return np.array(img)
                except:
                    # Если все равно ошибка, пробуем через cv2
                    return cv2.imread(path, cv2.IMREAD_UNCHANGED)
        else:
            # Для других форматов используем PIL
            return np.array(Image.open(path))
    except Exception as e:
        print(f"Ошибка чтения {path}: {str(e)}")
        return None

# 5. Класс Dataset с улучшенной обработкой ошибок
class SatelliteDataset(Dataset):
    def __init__(self, root_dir, classes, transform=None, mode='train'):
        self.samples = []
        self.transform = transform
        
        for class_name, color in classes.items():
            class_dir = os.path.join(root_dir, class_name)
            if not os.path.exists(class_dir):
                print(f"Предупреждение: папка {class_dir} не найдена")
                continue
                
            files = [f for f in os.listdir(class_dir) if f.lower().endswith(('.tif', '.tiff', '.png', '.jpg', '.jpeg'))]
            if not files:
                print(f"Предупреждение: в папке {class_dir} нет подходящих файлов")
                continue
                
            train_files, val_files = train_test_split(files, test_size=0.2, random_state=42)
            
            for f in (train_files if mode == 'train' else val_files):
                self.samples.append((os.path.join(class_dir, f), color))
        
        if not self.samples:
            raise ValueError(f"Не найдено изображений для {mode}")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        img_path, color = self.samples[idx]
        
        try:
            # Чтение изображения
            img = read_image(img_path)
            if img is None:
                raise ValueError(f"Не удалось прочитать изображение {img_path}")
                
            # Нормализация
            if img.dtype == np.uint16:
                img = (img / 256).astype(np.uint8)
            if len(img.shape) == 2:
                img = np.stack([img]*3, axis=-1)
            img = img[:,:,:3]
            
            # Приведение к размеру
            if img.shape[0] != 100 or img.shape[1] != 100:
                img = cv2.resize(img, (100, 100), interpolation=cv2.INTER_AREA)
            
            # Создание маски
            mask = np.zeros_like(img)
            mask[:] = color
            
            if self.transform:
                augmented = self.transform(image=img, mask=mask)
                img, mask = augmented['image'], augmented['mask']
            
            return transforms.ToTensor()(img), transforms.ToTensor()(mask)
            
        except Exception as e:
            print(f"Ошибка обработки {img_path}: {str(e)}")
            # Возвращаем нулевые тензоры в случае ошибки
            return torch.zeros(3, 100, 100), torch.zeros(3, 100, 100)

# 6. Функция для загрузки модели
def load_saved_model():
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = smp.Unet(
        'resnet34',
        encoder_weights=None,
        classes=3,
        activation='sigmoid'
    ).to(device)
    
    model_path = '/content/drive/MyDrive/Цифровая кафедра/Сигментация/best_model.pth'
    model.load_state_dict(torch.load(model_path))
    model.eval()
    return model, device

# 7. Функция визуализации предсказаний
def visualize_model_predictions(model, device, num_samples=5):
    try:
        val_dataset = SatelliteDataset(DATA_ROOT, CLASSES, val_transform, 'val')
    except Exception as e:
        print(f"Ошибка создания датасета: {str(e)}")
        return
    
    model.eval()
    
    plt.figure(figsize=(18, 4 * num_samples))
    
    for i in range(num_samples):
        try:
            idx = np.random.randint(len(val_dataset))
            image, true_mask = val_dataset[idx]
            image = image.unsqueeze(0).to(device)
            
            with torch.no_grad():
                pred_mask = model(image).sigmoid().squeeze().cpu()
            
            # Преобразуем тензоры в numpy массивы для визуализации
            image_np = image.squeeze().cpu().permute(1, 2, 0).numpy()
            true_mask_np = true_mask.permute(1, 2, 0).numpy()
            pred_mask_np = (pred_mask > 0.5).float().permute(1, 2, 0).numpy()
            
            # Нормализация изображения для отображения
            image_np = (image_np - image_np.min()) / (image_np.max() - image_np.min())
            
            # Оригинальное изображение
            plt.subplot(num_samples, 3, i*3 + 1)
            plt.imshow(image_np)
            plt.title(f"Пример {i+1}\n{os.path.basename(val_dataset.samples[idx][0])}")
            plt.axis('off')
            
            # Истинная маска
            plt.subplot(num_samples, 3, i*3 + 2)
            plt.imshow(true_mask_np)
            plt.title("Истинная маска")
            plt.axis('off')
            
            # Предсказанная маска
            plt.subplot(num_samples, 3, i*3 + 3)
            plt.imshow(pred_mask_np)
            plt.title("Предсказание модели")
            plt.axis('off')
            
        except Exception as e:
            print(f"Ошибка визуализации примера {i+1}: {str(e)}")
            continue
    
    plt.tight_layout()
    plt.show()

# 8. Основная функция
def main():
    print("Загрузка модели...")
    model, device = load_saved_model()
    print("Модель успешно загружена!")
    
    print("\nВизуализация предсказаний модели:")
    visualize_model_predictions(model, device, num_samples=5)

# Запуск
if __name__ == "__main__":
    main()
